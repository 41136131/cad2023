var tipuesearch = {"pages": [{'title': 'About', 'text': '個人倉儲: https://github.com/41136131/cad2023 \n 歡迎大駕光臨41136131的網站，一個可憐人爆肝弄出來的網站。 \n 老師拜託別當我，大俠饒命啊。 \n せー の っ\xa0 イン ター ネッ ト最 高！ \n \n', 'tags': '', 'url': 'About.html'}, {'title': 'Brython', 'text': 'https://en.wikipedia.org/wiki/Python_(programming_language) \n Examples: \n https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d \n https://www.geeksforgeeks.org/python-programming-examples/ \n https://www.programiz.com/python-programming/examples \n https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/ \n Python Tutorial: \n https://docs.python.org/3/tutorial/ \n An informal introduction to Python \n Indentation (Python 採 4 個 Spaces 縮排, 以界定執行範圍) \n Variables ( Python Keywords ) \n Comments (# 單行註解, 三個單引號或三個雙引號標註多行註解) \n Numbers  (整數 int(), 浮點數 float()) \n Strings  (字串) \n print (Python 內建函式,  print()  函式) \n Python control flow tools \n for \n if \n range \n open \n read \n lists \n tuples \n dictionaries \n functions \n try ... except \n break \n pass \n classes \n 這個頁面 demo 如何在同一頁面下納入多個線上 Ace 編輯器與執行按鈕 ( practice_html.txt  動態頁面超文件). \n practice_html.txt  動態頁面超文件應該可以在啟動 Brython 時, 設定將 .py 檔案放入 downloads/py 目錄中引用. \n 亦即將所有對應的 html 也使用 Brython 產生, 然後寫為  class  後, 在範例導入時透過  instance  引用. \n <!-- 啟動 Brython -->\n<script>\nwindow.onload=function(){\nbrython({debug:1, pythonpath:[\'./../cmsimde/static/\',\'./../downloads/py/\']});\n}\n</script> \n 從 1 累加到 100: \n 1 add to 100 \n 將 iterable 與 iterator  相關說明 , 利用 Brython 與 Ace Editor 整理在這個頁面. \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris Rotating Block \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n', 'tags': '', 'url': 'Brython.html'}, {'title': '任務一', 'text': '⇓傳送門⇓ \n 磁力吸引 \n \n magnet \n \n 馬達推動 \n 心得 \n \n', 'tags': '', 'url': '任務一.html'}, {'title': '磁力吸引', 'text': '有關磁力吸引的鋼球循環運動系統, 請參考 這個影片 . \xa0 或者透過課程檔案下載密碼觀看 這個影片 . \n 根據 這個網站 宣稱是此一 Perpetual Motion Simulator 的原始創作者. \n 同時參考\xa0 A perpetual motion machine powered by electromagnetism.pdf \xa0 (需要下載密碼) \n 電腦輔助設計與實習課程的任務一即可根據此一裝置的設計, 先採用電腦輔助設計軟體, 繪製系統所需的 3D 零組件, 然後轉為 STL 格式, import 進入 CoppeliaSim, 接著根據影片說明, 利用近接感測器(例如: \xa0 電感式近接開關 , \xa0 Inductive proximity sensor ) 控制電磁鐵開關, 設法透過磁力吸引讓鋼球具有足夠動能返回圓形平台. \n 有關利用 Arduino 控制卡與相關電路設計產生電磁力控制的模擬, 請參考 \xa0 PICSimLab \xa0 頁面中的說明. \n 一旦完成 CoppeliaSim 與 Arduino 電路設計等機電資系統整合模擬, 就可以進一步利用 3D printer 列印出所需零組件, 結合實體電路設計完成此一系統的虛實整合. \n 機電模擬系統: \n 下載支援 IPv6 網路協定版本 \xa0 CoppeliaSimEdu_4.5.1_rev4_for_cd2023.7z \xa0 (需要下載密碼) \n CoppeliaSim 使用者手冊 , \xa0 CoppeliaSim 4.3.0 使用手冊網站 \n 模擬磁力的 討論 , \xa0 1 , \xa0 2 \n Force Control Modeling \n simpleMagnetDemo.ttt \n 模擬原理: \n Perpetual Motion Simulator 主要的電路設計包含右側軌道下方的電磁鐵, 通電後可產生一定大小的磁吸力, 當圓形鐵球循著軌道由平台孔洞往下滾動, 經過軌道下方近接感測器 (Proximity sensor) 時 (距離 3mm-5mm), 透過感應, 控制電路將會短暫啟動電磁鐵 (10 miliseconds), 促使圓形鐵球加速滾動, 其磁力大小約略與圓形鐵球距離的平方成反比 ( Computational Electromagnetics , \xa0 磁場模擬 ). \n 因此圓形鐵球除了從平台高度落下時, 將位能轉換為動能外, 與軌道滾動磨擦以及空氣阻力所損耗的運動能, 將額外由電磁鐵開關間所得到的磁力吸引能量進行加速, 以便取得足夠的動能在脫離軌道末端後, 重新回到圓形平台. \n \n ( 圖源 ) \n 電磁力未啟動下的 perpetual motion simulator CoppeliaSim 場景模擬: \n \n Images and part files in Onshape \xa0 (STL file import into CoppeliaSim 尺寸由 mm 放大10 倍至 cm, 且 z 軸向上, 場景中圓球直徑為 12.825 cm, 平台圓孔直徑為 20 cm) \n \n Perpetual Motion Simulator in Onshape , 轉入 CoppeliaSim 後放大 10 倍, 且 z 軸向上之模擬場景, 下載 \xa0 perpetual motion simulator stage2.7z \xa0 (需要下載密碼) \n 有關如何在 Onshape 繪製零組件, 轉出 STL 檔案, 轉入 CoppeliaSim 並進行組件 divide and group, 請參考這個 教學影片 . \n 以下 Python 程式可在 CoppeliaSim 場景檔案中建立所需的模擬組件: \n 啟動\xa0 CoppeliaSimEdu_4.5.1_rev4_for_cd2023.7z \xa0 (支援 IPv6 網路協定版本, 需要下載密碼), 然後在 \xa0 Portable_2023_fall_1.3g_5g.7z \xa0 (需要下載密碼) 可攜環境啟動後, 以 pip install pyzmq cbor keyboard 安裝所需模組, 然後執行下列 zmqRemoteAPI IPv6 程式, 將滑鼠在場景中點擊後, 按下 q 鍵即可終止場景模擬: \n # zmqRemoteApi_IPv6 為將 zmq 通訊協定修改為 IPv4 與 IPv6 相容\n# pip install pyzmq cbor keyboard\nfrom zmqRemoteApi_IPv6 import RemoteAPIClient\nimport time\nimport math\nimport keyboard\n \n# 利用 zmqRemoteAPI 以 23000 對場景伺服器進行連線\nclient = RemoteAPIClient(\'localhost\', 23000)\n# 以 getObject 方法取得場景物件\nsim = client.getObject(\'sim\')\nbox = sim.getObject(\'/box\')\n \n# 啟動模擬\nsim.startSimulation()\n# 建立尺寸數列, 分別定義 x, y, z 方向尺寸\nx = 0.2\ny = 0.2\nz = 0.1\nsize = [x, y, z]\n \n# 利用 size 數列, 建立圓柱物件, 2 代表 cylinder\n# 8 表示 respondable, 1 為 質量\ndigit1_handle = sim.createPureShape(2, 8, size, 1, None)\n# 將圓柱物件命名為 digit1, 若用於機械計分可做為個位數轉盤\n# 之後可再導入帶有數字組立的外型零件\nsim.setObjectAlias(digit1_handle, \'digit1\')\n# 轉角單位為徑度\nsim.setObjectOrientation(digit1_handle, -1, [0, math.pi/2, 0])\n# 起始物件中心位於 [0, 0, 0], 為了位於地板, 往 z 提升一個半徑高度\nsim.setObjectPosition(digit1_handle, -1, [0, 0, x/2])\n \n# 建立 revolute joint 命名為 joint, 且將 joint mode 設為 dynamic, control mode 設為 velocity\njoint1_handle = sim.createJoint(sim.joint_revolute_subtype, sim.jointmode_dynamic, 0, None)\nsim.setObjectInt32Param(joint1_handle, sim.jointintparam_dynctrlmode, sim.jointdynctrl_velocity)\nsim.setObjectAlias(joint1_handle, \'joint1\')\n \n# 取得 cylinder 的位置座標\ndigit1_pos = sim.getObjectPosition(digit1_handle, -1)\njoint1_pos = [digit1_pos[0], digit1_pos[1], digit1_pos[2]]\n \n# 將 joint1 至於 cylinder 中心\nsim.setObjectPosition(joint1_handle, -1, joint1_pos)\n# 取得 digit1_handle 的方位\ndigit1_ori = sim.getObjectOrientation(digit1_handle, -1)\n# 將 joint1_handle 方位與 digit1 對齊\nsim.setObjectOrientation(joint1_handle, -1, digit1_ori)\n \n# 將 joint1 置於 box 上\nsim.setObjectParent(joint1_handle, box, True)\n# 將 cylinder 置於 joint1 上\nsim.setObjectParent(digit1_handle, joint1_handle, True)\n \n# 鎖定 joint1\nsim.setJointForce(joint1_handle, float(\'inf\'))\n \nprint("基本場景建立完成!")\n \n# 設定主迴圈\nwhile True:\n    # 設定 joint1 目標速度\n    sim.setJointTargetVelocity(joint1_handle, 10)\n    # 讓 coppeliasim 有時間按照設定讓 joint1 旋轉\n    time.sleep(0.01) \n \n    if keyboard.is_pressed(\'q\'):\n        # 可以按下 q 鍵跳出重複執行迴圈\n        break\n \n# 終止模擬\nsim.stopSimulation() \n 下載 \xa0 zmqRemoteAPI Python for cad2023.7z \xa0 (需要下載密碼) \n 在 \xa0 simpleMagnetDemo.ttt \xa0 中利用 Lua 以 proximity sensor 感測與物體的距離後, 產生電磁吸引力的範例程式: \n function sysCall_init()\n     -- 初始化 callback 函數，在模擬開始時執行\n     sensor = sim.getObject(\'./sensor\')\n     -- 取得命名為 \'sensor\' 的物件 handle。 此處使用 proximity 感測器，用於檢測物體之間的距離\n     shape = sim.getObject(\'.\')\n     -- 取得目前 script 所依附的物件 handle，即包含此 script 的物件 handle\n     sim.setObjectInt32Param(shape, sim.shapeintparam_static, 0)\n     -- 將物體設定為非靜態，讓其在模擬中發生動態運動\n     nominalForce = 0.001\n     -- 設定電磁吸引力的標準值\n     enabled = true\n     -- 啟用電磁吸引力\n     previousPos = sim.getObjectPosition(shape, sim.handle_world)\n     -- 取得物體的初始位置並儲存在 previousPos 變數中，用於偵測物體是否移動\nend\n \nfunction sysCall_actuation()\n     -- 驅動 callback 函數，在每個模擬步驟中執行\n     if enabled then\n         -- 如果啟用電磁吸引力，執行下列程式碼\n         local r, dist, pt, obj = sim.handleProximitySensor(sensor)\n         -- 使用 proximity 感測器偵測物體是否接近\n         if r > 0 then\n             -- 如果偵測到物體\n             dist = dist + 0.02\n             -- 增加一個 offset，以避免物體接觸時產生無限大的吸引力\n             local force = nominalForce / (dist * dist)\n             -- 計算吸引力的大小，與距離的平方成反比\n             local m = sim.getObjectMatrix(shape, sim.handle_world)\n             m[4] = 0\n             m[8] = 0\n             m[12] = 0\n             -- 取得物體的轉換矩陣，不考慮平移部分\n             local forceVector = sim.multiplyVector(m, {0, 0, force})\n             -- 將力向量從局部座標系轉換為絕對座標系\n             sim.addForceAndTorque(shape, forceVector, {0, 0, 0})\n             -- 將計算得到的力應用於物體的質心，持續一個 time step\n             if notFirstPass then\n                 local p = sim.getObjectPosition(shape, sim.handle_world)\n                 local dx = {p[1] - previousPos[1], p[2] - previousPos[2], p[3] - previousPos[3]}\n                 local d = math.sqrt(dx[1] * dx[1] + dx[2] * dx[2] + dx[3] * dx[3])\n                 -- 計算物體是否移動\n                 if d < 0.0001 then\n                     sim.setObjectInt32Param(shape, sim.shapeintparam_static, 1)\n                     sim.resetDynamicObject(shape)\n                     enabled = false\n                     -- 如果物體沒有移動，將其設為靜態\n                 end\n                 previousPos = p\n             end\n         end\n     end\n     notFirstPass = true\nend \n', 'tags': '', 'url': '磁力吸引.html'}, {'title': 'magnet', 'text': '利用 Lua 模擬磁力的程式碼: \n function sysCall_init()\n \n-- This line defines the beginning of a function called sysCall_init(). This function is a special callback function in CoppeliaSim that gets called once when the simulation starts.\n \n    sensor = sim.getObject(\'./sensor\')\n \n-- In this line, the script is getting a reference to an object named "sensor" in the simulation scene. This object is expected to exist within the same hierarchy as the script.\n \n    shape = sim.getObject(\'.\')\n \n-- Here, the script is getting a reference to the object where the script is attached. The dot . represents the current object.\n \n    sim.setObjectInt32Param(shape, sim.shapeintparam_static, 0)\n \n-- This line is setting an integer parameter for the "shape" object. Specifically, it\'s setting the sim.shapeintparam_static parameter to 0. This means that the "shape" object is initially not considered as a static object.\n \n    nominalForce = 0.001\n \n-- This line sets a variable nominalForce to a value of 0.001. It appears to represent a constant force value used in the script.\n \n    enabled = true\n \n-- This line initializes a boolean variable enabled to true. This variable seems to control whether the script should apply forces or not.\n \n    previousPos = sim.getObjectPosition(shape, sim.handle_world)\n \n-- Here, the script is getting the initial position of the "shape" object in the world coordinate system and storing it in the previousPos variable. This will be used later for checking if the object has moved.\n \n-- The sysCall_init function sets up initial parameters and conditions for the script. It\'s executed once at the beginning of the simulation.\n \n-- Now, let\'s move on to the sysCall_actuation function:\n \nfunction sysCall_actuation()\n \n-- This line defines the beginning of another special callback function in CoppeliaSim called sysCall_actuation(). This function gets called repeatedly during the simulation to perform actions in each time step.\n \n    if enabled then\n \n-- This line checks if the enabled variable is true. If it\'s true, it means the script should apply forces. If it\'s false, the script won\'t apply any forces.\n \n        local r, dist, pt, obj = sim.handleProximitySensor(sensor)\n \n-- Here, the script is using the sim.handleProximitySensor function to check if the proximity sensor (defined earlier as "sensor") is detecting any objects nearby. It returns information about the detected object.\n \n        if r > 0 then\n \n-- This line checks if r (the return value of the proximity sensor function) is greater than 0. If it is, it means the sensor has detected an object nearby.\n \n            dist = dist + 0.02\n \n-- This line adds an offset of 0.02 to the dist variable. This offset is added to prevent an infinite force when objects are in direct contact. It\'s a safety measure.\n \n            local force = nominalForce / (dist * dist)\n \n-- Here, the script calculates the force to be applied based on the nominalForce and the squared distance (dist) between the object and the detected object. This seems to be a simple inverse square law force calculation.\n \n            local m = sim.getObjectMatrix(shape, sim.handle_world)\n            m[4] = 0\n            m[8] = 0\n            m[12] = 0\n \n-- These lines retrieve the transformation matrix (m) of the "shape" object with respect to the world coordinate system and set its translational components to 0. This effectively extracts the rotational part of the transformation matrix.\n \n            local forceVector = sim.multiplyVector(m, {0, 0, force})\n \n-- This line multiplies the modified transformation matrix m by a force vector {0, 0, force} to obtain a force vector in absolute world coordinates.\n \n            sim.addForceAndTorque(shape, forceVector, {0, 0, 0})\n \n-- Here, the script applies the computed forceVector to the "shape" object using sim.addForceAndTorque. This function applies the force to the center of mass of the object for one simulation time step.\n \n            if notFirstPass then\n \n-- This line checks if the notFirstPass variable is true. It\'s used to ensure that this part of the script is executed after the first simulation step.\n \n                local p = sim.getObjectPosition(shape, sim.handle_world)\n \n-- Here, the script is getting the current position of the "shape" object in the world coordinate system.\n \n                local dx = {p[1] - previousPos[1], p[2] - previousPos[2], p[3] - previousPos[3]}\n \n-- This line calculates the difference in position (dx) between the current position (p) and the previous position (previousPos) of the object in world coordinates.\n \n                local d = math.sqrt(dx[1] * dx[1] + dx[2] * dx[2] + dx[3] * dx[3])\n \n-- The script calculates the Euclidean distance d based on the differences in position components dx. This distance is used to check if the object has moved significantly.\n \n                if d < 0.0001 then\n \n-- This line checks if the object has moved by comparing d to a small threshold value (0.0001). If d is less than the threshold, it means the object hasn\'t moved significantly.\n \n                    sim.setObjectInt32Param(shape, sim.shapeintparam_static, 1)\n \n-- If the object hasn\'t moved significantly, this line sets the sim.shapeintparam_static parameter to 1, making the object static in the simulation.\n \n                    sim.resetDynamicObject(shape)\n \n-- This line resets the dynamics of the object. It might be necessary to reset the object\'s dynamics after making it static to avoid any issues.\n \n                    enabled = false\n \n-- Finally, this line sets the enabled variable to false, which will prevent the script from applying further forces since the object is now considered static and not moving.\n \n                end\n \n-- The if block is closed.\n \n                previousPos = p\n \n-- Regardless of whether the object has become static or not, the previousPos variable is updated with the current position for use in the next iteration of the sysCall_actuation function.\n \n            end\n \n-- The if notFirstPass block is closed.\n \n        end\n \n-- The if r > 0 block is closed.\n \n    end\n \n-- The if enabled block is closed.\n \n    notFirstPass = true\n \n-- This line sets the notFirstPass variable to `true \n', 'tags': '', 'url': 'magnet.html'}, {'title': '馬達推動', 'text': '除了利用磁力吸引, 讓鋼球在軌道運動時能具備足夠動能返回圓形平台外, 另外一種設計是在鋼球 (或其他非鐵材質的圓球) 離開圓形平台孔洞之後, 設法利用隱藏式的馬達帶動機構, 以滾動方式加速圓球, 以便讓圓球返回平台. \n 有關馬達推動設計, 請參考: \xa0 https://www.instructables.com/Marblevator-Perpetual/ \xa0 或 這個影片 . \n 機電模擬系統: \n 下載 \xa0 CoppeliaSimEdu_4.5.1_rev4_for_cd2023.7z \xa0 (需要下載密碼) \n CoppeliaSim 使用者手冊 , \xa0 CoppeliaSim 4.3.0 使用手冊網站 \n', 'tags': '', 'url': '馬達推動.html'}, {'title': '心得', 'text': '老師對不起我東西都是嫖來的，但是我已經努力了，至少是東西是自己親手推的，請高抬貴手放過我吧QAQ。 \n \n', 'tags': '', 'url': '心得.html'}, {'title': '個人評分', 'text': '⇓傳送門⇓ \n 更新日誌 \n \n 自我評分 \n \n', 'tags': '', 'url': '個人評分.html'}, {'title': '更新日誌', 'text': '2024/01/11:新增首頁圖片 \n 2024/01/11:新增個人簡介 \n 2024/01/11:新增個人評分 \n 2024/01/16:新增任務一 \n 2024/01/16:新增磁力吸引 \n 2024/01/16:新增magnet \n 2024/01/16:新增馬達推動 \n 2024/01/16:新增心得 \n', 'tags': '', 'url': '更新日誌.html'}, {'title': '自我評分', 'text': ' Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n 自評分數:60分 \n 我知道以我的網站想要拿60分確實非常厚臉皮，但是我還是希望這門課可以通過，雖然網頁是在最後一個禮拜趕出來的，而且也沒有什麼東西，不過我還是在個人網頁上花了不少心思跟精力，讓我的網頁從0到有，最重要的是我網頁是我自己用的不假借他人之手，但是不可否認我在遇到瓶頸時受到了其他同學的幫助，但是我還是秉持著自己的作業自己做的精神把它給完成了。 \n \n \n \n \n  editor2 結束  \n \n \n', 'tags': '', 'url': '自我評分.html'}]};