<h1>About</h1>
<p>個人倉儲:<a href="https://github.com/41136131/cad2023" title="https://github.com/41136131/cad2023">https://github.com/41136131/cad2023</a></p>
<p>歡迎大駕光臨41136131的網站，一個可憐人爆肝弄出來的網站。<em></em><strong></strong></p>
<p>老師拜託別當我，大俠饒命啊。</p>
<p><span style="background-color: #e3e3e3;"><span jsname="YS01Ge"><span style="color: #3366ff;"><span style="color: #800080;"><span style="color: #ff0000;">せー<span style="color: #ff6600;">の</span></span><span style="color: #ff6600;">っ </span><span jsname="YS01Ge"><span style="color: #ffff00;">イン</span><span style="color: #00ff00;">ター</span><span style="color: #3366ff;">ネッ<span style="color: #0000ff;">ト最</span><span style="color: #800080;">高！</span></span></span></span></span></span></span></p>
<p><img alt="" height="318" src="/images/saiko.png" width="567"/></p>
<h1>Brython</h1>
<p><a href="https://en.wikipedia.org/wiki/Python_(programming_language)">https://en.wikipedia.org/wiki/Python_(programming_language)</a></p>
<h4>Examples:</h4>
<p style="padding-left: 30px;"><a href="https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d">https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d</a></p>
<p style="padding-left: 30px;"><a href="https://www.geeksforgeeks.org/python-programming-examples/">https://www.geeksforgeeks.org/python-programming-examples/</a></p>
<p style="padding-left: 30px;"><a href="https://www.programiz.com/python-programming/examples">https://www.programiz.com/python-programming/examples</a></p>
<p style="padding-left: 30px;"><a href="https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/">https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/</a></p>
<h4>Python Tutorial:</h4>
<p style="padding-left: 30px;"><a href="https://docs.python.org/3/tutorial/">https://docs.python.org/3/tutorial/</a></p>
<p style="padding-left: 30px;"><a href="https://docs.python.org/3/tutorial/introduction.html">An informal introduction to Python</a></p>
<h4>Indentation (Python 採 4 個 Spaces 縮排, 以界定執行範圍)</h4>
<h4>Variables (<a href="https://github.com/python/cpython/blob/3.11/Lib/keyword.py">Python Keywords</a>)</h4>
<h4>Comments (# 單行註解, 三個單引號或三個雙引號標註多行註解)</h4>
<h4><a href="https://docs.python.org/3/tutorial/introduction.html#numbers">Numbers</a> (整數 int(), 浮點數 float())</h4>
<h4><a href="https://docs.python.org/3/tutorial/introduction.html#strings">Strings</a> (字串)</h4>
<h4>print (Python 內建函式, <a href="https://docs.python.org/3/library/functions.html#print">print()</a> 函式)</h4>
<p><a href="https://docs.python.org/3/tutorial/controlflow.html">Python control flow tools</a></p>
<h4 style="padding-left: 30px;"><a href="https://docs.python.org/3/tutorial/controlflow.html#for-statements">for</a></h4>
<h4 style="padding-left: 30px;"><a href="https://docs.python.org/3/tutorial/controlflow.html#if-statements">if</a></h4>
<h4 style="padding-left: 30px;"><a href="https://docs.python.org/3/tutorial/controlflow.html#the-range-function">range</a></h4>
<h4>open</h4>
<h4>read</h4>
<h4><a href="https://docs.python.org/3/tutorial/introduction.html#lists">lists</a></h4>
<h4><a href="https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences">tuples</a></h4>
<h4><a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries">dictionaries</a></h4>
<h4><a href="https://docs.python.org/3/tutorial/controlflow.html#defining-functions">functions</a></h4>
<h4><a href="https://docs.python.org/3/tutorial/errors.html#exceptions">try ... except</a></h4>
<h4><a href="https://docs.python.org/3/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops">break</a></h4>
<h4><a href="https://docs.python.org/3/tutorial/controlflow.html#pass-statements">pass</a></h4>
<h4><a href="https://docs.python.org/3/tutorial/classes.html?highlight=classes">classes</a></h4>
<p>這個頁面 demo 如何在同一頁面下納入多個線上 Ace 編輯器與執行按鈕 (<a href="/downloads/practice_html.txt">practice_html.txt</a> 動態頁面超文件).</p>
<p><a href="/downloads/practice_html.txt">practice_html.txt</a> 動態頁面超文件應該可以在啟動 Brython 時, 設定將 .py 檔案放入 downloads/py 目錄中引用.</p>
<p>亦即將所有對應的 html 也使用 Brython 產生, 然後寫為 <a href="https://docs.python.org/3/tutorial/classes.html">class</a> 後, 在範例導入時透過 <a href="https://docs.python.org/3/tutorial/classes.html#instance-objects">instance</a> 引用.</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;!-- 啟動 Brython --&gt;
&lt;script&gt;
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
&lt;/script&gt;</pre>
<p>從 1 累加到 100:</p>
<p><button id="add1to100">1 add to 100</button></p>
<p>將 iterable 與 iterator <a href="https://home.gamer.com.tw/creationDetail.php?sn=4337438">相關說明</a>, 利用 Brython 與 Ace Editor 整理在這個頁面.</p>
<!-- 導入 brython 程式庫 -->
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
</p>
<!-- 啟動 Brython -->
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
</p>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫 -->
<script src="/static/Cango-24v03-min.js"></script>
<script src="/static/gearUtils-09.js"></script>
<script src="/static/SVGpathUtils-6v03-min.js"></script>
<script src="/static/sylvester.js"></script>
<script src="/static/PrairieDraw.js"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()
Ace1 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run1():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src"]
    except:
        url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c3a6deaf717f8f2739a4b1392a5ab10936e9693a/from_1_add_to_10_1.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace1.editor.setValue(prog)
    Ace1.editor.scrollToRow(0)
    Ace1.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace1.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run1'].bind('click', Ace1.run)
doc['kw_show_console1'].bind('click', Ace1.show_console)
doc['kw_clear_console1'].bind('click', Ace1.clear_console)
doc['clear_bd1'].bind('click', clear_bd1)
# 呼叫函式執行
run1()
</script>
</p>
<p><!-- add 1 to 100 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace2 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )

add1to100_url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add(ev):
    Ace2.editor.setValue(add_src)
    Ace2.editor.scrollToRow(0)
    Ace2.editor.gotoLine(0)
    Ace2.run()

# id 為 "add1to100" 的按鈕點按時, 執行 add 方法
doc["add1to100"].bind('click', add)
</script>
</p>
<p><!-- add 1 to 100 結束--></p>
<!-- editor1 開始 -->
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor1" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src1', 'kw_filename1');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run1">Run</button> <button id="kw_show_console1">Output</button> <button id="kw_clear_console1">清除輸出區</button><button id="clear_bd1">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console1"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div1"></div>
<!-- editor1 結束 --><hr/><!-- ########################################## -->
<p>從 1 累加到 100 part2:</p>
<p><button id="add1to100part2">1 add to 100</button><button id="cango_three_gears">cango_three_gears</button><button id="bsnake">BSnake</button><button id="aitetris">AI Tetris</button><button id="threejsblock">Rotating Block</button></p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd2(ev):
    bd = doc["brython_div2"]
    bd.clear()
Ace3 = ace.Editor(editor_id="kw_editor2", console_id="kw_console2", container_id="kw__container2", storage_id="kw_py_src2" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run2():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src2"]
    except:
        url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c3a6deaf717f8f2739a4b1392a5ab10936e9693a/from_1_add_to_10_1.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace3.editor.setValue(prog)
    Ace3.editor.scrollToRow(0)
    Ace3.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace3.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run2'].bind('click', Ace3.run)
doc['kw_show_console2'].bind('click', Ace3.show_console)
doc['kw_clear_console2'].bind('click', Ace3.clear_console)
doc['clear_bd2'].bind('click', clear_bd2)
# 呼叫函式執行
run2()
</script>
</p>
<p><!-- add 1 to 100 part2 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd2(ev):
    bd = doc["brython_div2"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace4 = ace.Editor(editor_id="kw_editor2", console_id="kw_console2", container_id="kw__container2", storage_id="kw_py_src2" )

# 透過 Ace4 以類別建立一個通用的 button2, 可以在多個案例中將 gist 程導入編輯區

class button2:
    def __init__(self, url):
        self.url = url

    # 記得加入 event 輸入變數
    def do(self,ev):
        Ace4.editor.setValue(open(self.url).read())
        Ace4.editor.scrollToRow(0)
        Ace4.editor.gotoLine(0)
        Ace4.run()

add1to100_url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add2(ev):
    Ace4.editor.setValue(add_src)
    Ace4.editor.scrollToRow(0)
    Ace4.editor.gotoLine(0)
    Ace4.run()

# id 為 "add1to100part2" 的按鈕點按時, 執行 add 方法
doc["add1to100part2"].bind('click', add2)
# 以下為運用 button2 class 的通用 gist 程式導入區
################################## cango_three_gears start
cango_three_gears_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/cango_three_gears_brython_div2.py"
cango_three_gears = button2(cango_three_gears_url)
doc["cango_three_gears"].bind("click", cango_three_gears.do)
################################## cango_three_gears end
################################## bsnake start
bsnake_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/kmol_snakey.py"
bsnake = button2(bsnake_url)
doc["bsnake"].bind("click", bsnake.do)
################################## bsnake end
################################## aitetris start
aitetris_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/pygame_to_brython_tetris_ai.py"
aitetris = button2(aitetris_url)
doc["aitetris"].bind("click", aitetris.do)
################################## aitetris end
################################## threejsblock start
threejsblock_url = "https://gist.githubusercontent.com/mdecycu/2c6323eff49b496d1bafd210f3ec9707/raw/df37802f9e8a386b6424f7945af622b1cd0a9ca5/threejs_rotating_block.py"
threejsblock = button2(threejsblock_url)
doc["threejsblock"].bind("click", threejsblock.do)
################################## threejsblock end
</script>
</p>
<p><!-- add 1 to 100 part2 結束--></p>
<!-- editor2 開始 -->
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor2" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename2" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src2', 'kw_filename2');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run2">Run</button> <button id="kw_show_console2">Output</button> <button id="kw_clear_console2">清除輸出區</button><button id="clear_bd2">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console2"></textarea></div>
<h1 style="width: 100%; height: 100%;">任務一</h1>
<p>⇓傳送門⇓</p>
<p><a href="https://41136131.github.io/cad2023/content/%E7%A3%81%E5%8A%9B%E5%90%B8%E5%BC%95.html">磁力吸引</a></p>
<p><a href="https://41136131.github.io/cad2023/content/%E7%A3%81%E5%8A%9B%E5%90%B8%E5%BC%95.html"><img alt="" height="159" src="/images/portal.gif" width="159"/></a></p>
<p><a href="https://41136131.github.io/cad2023/content/magnet.html">magnet</a></p>
<p><a href="https://41136131.github.io/cad2023/content/magnet.html"><img alt="" height="159" src="/images/portal.gif" width="159"/></a></p>
<p><a href="https://41136131.github.io/cad2023/content/%E9%A6%AC%E9%81%94%E6%8E%A8%E5%8B%95.html">馬達推動</a><br/><a href="https://41136131.github.io/cad2023/content/%E9%A6%AC%E9%81%94%E6%8E%A8%E5%8B%95.html"><img alt="" height="159" src="/images/portal.gif" width="159"/><br/></a></p>
<p><a href="https://41136131.github.io/cad2023/content/%E5%BF%83%E5%BE%97.html">心得</a></p>
<p><a href="https://41136131.github.io/cad2023/content/%E5%BF%83%E5%BE%97.html"><img alt="" height="159" src="/images/portal.gif" width="159"/></a></p>
<h2>磁力吸引</h2>
<p><span>有關磁力吸引的鋼球循環運動系統, 請參考</span><a href="https://youtu.be/r_LG8FDt51U?si=D6TZP_XarNUvVOye">這個影片</a><span>.<span> </span></span><span>或者透過課程檔案下載密碼觀看<a href="https://nfuedu-my.sharepoint.com/:v:/g/personal/yen_nfu_edu_tw/EcDmEvU3PKREq_noqkc_FeABZhbpfQ5p-f-3LuZn-PAQ1g?nav=eyJyZWZlcnJhbEluZm8iOnsicmVmZXJyYWxBcHAiOiJPbmVEcml2ZUZvckJ1c2luZXNzIiwicmVmZXJyYWxBcHBQbGF0Zm9ybSI6IldlYiIsInJlZmVycmFsTW9kZSI6InZpZXciLCJyZWZlcnJhbFZpZXciOiJNeUZpbGVzTGlua0RpcmVjdCJ9fQ&amp;e=vF0sTa">這個影片</a>.</span></p>
<p><span>根據<a href="https://www.etsy.com/listing/1253569674/perpetual-machine-simulator-perpetual">這個網站</a>宣稱是此一 Perpetual Motion Simulator 的原始創作者.</span></p>
<p><span>同時參考 <a href="https://nfuedu-my.sharepoint.com/:b:/g/personal/yen_nfu_edu_tw/ETvxcyDptUtMlUj22ato4RYBJc5ekzCuC1pGFcOmUSXK3w?e=2miuR4">A perpetual motion machine powered by electromagnetism.pdf</a><span> </span>(需要下載密碼)</span></p>
<p>電腦輔助設計與實習課程的任務一即可根據此一裝置的設計, 先採用電腦輔助設計軟體, 繪製系統所需的 3D 零組件, 然後轉為 STL 格式, import 進入 CoppeliaSim, 接著根據影片說明, 利用近接感測器(例如:<span> </span><a href="https://shopee.tw/%E9%9B%BB%E6%84%9F%E5%BC%8F-%E6%8E%A5%E8%BF%91%E9%96%8B%E9%97%9C-SN04N-SN04P-SN04Y-NPN-%E7%9B%B4%E6%B5%813%E7%B7%9A-%E5%9F%8B%E5%85%A5%E5%BC%8F-%E6%98%8E%E6%AD%A6%E6%A8%A1%E7%B5%84-i.795631261.18472134425">電感式近接開關</a>,<span> </span><a href="https://www.amazon.com/-/en/LY346/dp/B07V4PR84Y">Inductive proximity sensor</a>) 控制電磁鐵開關, 設法透過磁力吸引讓鋼球具有足夠動能返回圓形平台.</p>
<p>有關利用 Arduino 控制卡與相關電路設計產生電磁力控制的模擬, 請參考<span> </span><a href="https://mde.tw/cad2023/content/PICSimLab.html">PICSimLab</a><span> </span>頁面中的說明.</p>
<p>一旦完成 CoppeliaSim 與 Arduino 電路設計等機電資系統整合模擬, 就可以進一步利用 3D printer 列印出所需零組件, 結合實體電路設計完成此一系統的虛實整合.</p>
<p>機電模擬系統:</p>
<p>下載支援 IPv6 網路協定版本<span> </span><a href="https://nfuedu-my.sharepoint.com/:u:/g/personal/yen_nfu_edu_tw/EfEaYO4E4eBGtTV3QBCP0f0B3JBfrw11LslWmQyqZB75fw?e=Zf7hCp">CoppeliaSimEdu_4.5.1_rev4_for_cd2023.7z</a><span> </span>(需要下載密碼)</p>
<p><a href="https://www.coppeliarobotics.com/helpFiles/">CoppeliaSim 使用者手冊</a>,<span> </span><a href="https://mde.tw/pjcopsim">CoppeliaSim 4.3.0 使用手冊網站</a></p>
<p>模擬磁力的<a href="https://forum.coppeliarobotics.com/viewtopic.php?t=3923">討論</a>,<span> </span><a href="https://forum.coppeliarobotics.com/viewtopic.php?t=1501">1</a>,<span> </span><a href="https://forum.coppeliarobotics.com/viewtopic.php?t=7187">2</a></p>
<p><a href="https://studywolf.wordpress.com/2016/04/18/using-vrep-for-simulation-of-force-controlled-models/">Force Control Modeling</a></p>
<p><a href="https://github.com/CoppeliaRobotics/scenes/raw/master/otherScenes/simpleMagnetDemo.ttt">simpleMagnetDemo.ttt</a></p>
<p>模擬原理:</p>
<p>Perpetual Motion Simulator 主要的電路設計包含右側軌道下方的電磁鐵, 通電後可產生一定大小的磁吸力, 當圓形鐵球循著軌道由平台孔洞往下滾動, 經過軌道下方近接感測器 (Proximity sensor) 時 (距離 3mm-5mm), 透過感應, 控制電路將會短暫啟動電磁鐵 (10 miliseconds), 促使圓形鐵球加速滾動, 其磁力大小約略與圓形鐵球距離的平方成反比 (<a href="https://en.wikipedia.org/wiki/Computational_electromagnetics">Computational Electromagnetics</a>,<span> </span><a href="https://javalab.org/en/magnetic_field_around_a_coil_en/">磁場模擬</a>).</p>
<p>因此圓形鐵球除了從平台高度落下時, 將位能轉換為動能外, 與軌道滾動磨擦以及空氣阻力所損耗的運動能, 將額外由電磁鐵開關間所得到的磁力吸引能量進行加速, 以便取得足夠的動能在脫離軌道末端後, 重新回到圓形平台.</p>
<p><img alt="" height="367" src="/images/1.png" width="491"/></p>
<p><span>(<a href="https://www.etsy.com/listing/1253569674/perpetual-machine-simulator-perpetual">圖源</a></span><span>)</span></p>
<p><span>電磁力未啟動下的 perpetual motion simulator CoppeliaSim 場景模擬:</span></p>
<p><span><img alt="" height="368" src="/images/02.gif" width="487"/></span></p>
<p><span><a href="https://cad.onshape.com/documents/42e52a740033264a7d82e595/w/2f1d43f82796f4e05a79c0b5/e/f2fa8150f24c8a3d1aa4d036?renderMode=0&amp;uiState=650b848e93b8b544db72a044">Images and part files in Onshape</a><span><span> </span>(STL file import into CoppeliaSim 尺寸由 mm 放大10 倍至 cm, 且 z 軸向上, 場景中圓球直徑為 12.825 cm, 平台圓孔直徑為 20 cm)</span></span></p>
<p><span><span><img alt="" height="400" src="/images/03.gif" width="486"/></span></span></p>
<p><span><span><a href="https://cad.onshape.com/documents/42e52a740033264a7d82e595/w/2f1d43f82796f4e05a79c0b5/e/f2fa8150f24c8a3d1aa4d036?renderMode=0&amp;uiState=651e2855dd2e77079352b937">Perpetual Motion Simulator in Onshape</a><span>, 轉入 CoppeliaSim 後放大 10 倍, 且 z 軸向上之模擬場景, 下載<span> </span></span><a href="https://nfuedu-my.sharepoint.com/:u:/g/personal/yen_nfu_edu_tw/EVInN4wwqbpAuAv14NeTfpIB-7Q3hshxyaR38R9fd9fbkw?e=jZhpZQ">perpetual motion simulator stage2.7z</a><span><span> </span>(需要下載密碼)</span></span></span></p>
<p>有關如何在 Onshape 繪製零組件, 轉出 STL 檔案, 轉入 CoppeliaSim 並進行組件 divide and group, 請參考這個<a href="https://nfuedu-my.sharepoint.com/:v:/g/personal/yen_nfu_edu_tw/EQkDoYGPTlRBi4iK288VMXQB4dH92ieYRUf1c4h5IjHU0A?nav=eyJyZWZlcnJhbEluZm8iOnsicmVmZXJyYWxBcHAiOiJPbmVEcml2ZUZvckJ1c2luZXNzIiwicmVmZXJyYWxBcHBQbGF0Zm9ybSI6IldlYiIsInJlZmVycmFsTW9kZSI6InZpZXciLCJyZWZlcnJhbFZpZXciOiJNeUZpbGVzTGlua0RpcmVjdCJ9fQ&amp;e=wYUHv2">教學影片</a>.</p>
<p>以下 Python 程式可在 CoppeliaSim 場景檔案中建立所需的模擬組件:</p>
<p><span>啟動 </span><a href="https://nfuedu-my.sharepoint.com/:u:/g/personal/yen_nfu_edu_tw/EfEaYO4E4eBGtTV3QBCP0f0B3JBfrw11LslWmQyqZB75fw?e=Zf7hCp">CoppeliaSimEdu_4.5.1_rev4_for_cd2023.7z</a><span><span> </span>(支援 IPv6 網路協定版本, 需要下載密碼), 然後在<span> </span></span><a href="https://nfuedu-my.sharepoint.com/:u:/g/personal/yen_nfu_edu_tw/EQTW-mq62DpFtw5It9ao-PIBPXW7z5z8oVsW5gd8zbDXOQ?e=q6gHgf">Portable_2023_fall_1.3g_5g.7z</a><span><span> </span>(需要下載密碼) 可攜環境啟動後, 以 pip install pyzmq cbor keyboard 安裝所需模組, 然後執行下列 zmqRemoteAPI IPv6 程式, 將滑鼠在場景中點擊後, 按下 q 鍵即可終止場景模擬:</span></p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false"># zmqRemoteApi_IPv6 為將 zmq 通訊協定修改為 IPv4 與 IPv6 相容
# pip install pyzmq cbor keyboard
from zmqRemoteApi_IPv6 import RemoteAPIClient
import time
import math
import keyboard
 
# 利用 zmqRemoteAPI 以 23000 對場景伺服器進行連線
client = RemoteAPIClient('localhost', 23000)
# 以 getObject 方法取得場景物件
sim = client.getObject('sim')
box = sim.getObject('/box')
 
# 啟動模擬
sim.startSimulation()
# 建立尺寸數列, 分別定義 x, y, z 方向尺寸
x = 0.2
y = 0.2
z = 0.1
size = [x, y, z]
 
# 利用 size 數列, 建立圓柱物件, 2 代表 cylinder
# 8 表示 respondable, 1 為 質量
digit1_handle = sim.createPureShape(2, 8, size, 1, None)
# 將圓柱物件命名為 digit1, 若用於機械計分可做為個位數轉盤
# 之後可再導入帶有數字組立的外型零件
sim.setObjectAlias(digit1_handle, 'digit1')
# 轉角單位為徑度
sim.setObjectOrientation(digit1_handle, -1, [0, math.pi/2, 0])
# 起始物件中心位於 [0, 0, 0], 為了位於地板, 往 z 提升一個半徑高度
sim.setObjectPosition(digit1_handle, -1, [0, 0, x/2])
 
# 建立 revolute joint 命名為 joint, 且將 joint mode 設為 dynamic, control mode 設為 velocity
joint1_handle = sim.createJoint(sim.joint_revolute_subtype, sim.jointmode_dynamic, 0, None)
sim.setObjectInt32Param(joint1_handle, sim.jointintparam_dynctrlmode, sim.jointdynctrl_velocity)
sim.setObjectAlias(joint1_handle, 'joint1')
 
# 取得 cylinder 的位置座標
digit1_pos = sim.getObjectPosition(digit1_handle, -1)
joint1_pos = [digit1_pos[0], digit1_pos[1], digit1_pos[2]]
 
# 將 joint1 至於 cylinder 中心
sim.setObjectPosition(joint1_handle, -1, joint1_pos)
# 取得 digit1_handle 的方位
digit1_ori = sim.getObjectOrientation(digit1_handle, -1)
# 將 joint1_handle 方位與 digit1 對齊
sim.setObjectOrientation(joint1_handle, -1, digit1_ori)
 
# 將 joint1 置於 box 上
sim.setObjectParent(joint1_handle, box, True)
# 將 cylinder 置於 joint1 上
sim.setObjectParent(digit1_handle, joint1_handle, True)
 
# 鎖定 joint1
sim.setJointForce(joint1_handle, float('inf'))
 
print("基本場景建立完成!")
 
# 設定主迴圈
while True:
    # 設定 joint1 目標速度
    sim.setJointTargetVelocity(joint1_handle, 10)
    # 讓 coppeliasim 有時間按照設定讓 joint1 旋轉
    time.sleep(0.01) 
 
    if keyboard.is_pressed('q'):
        # 可以按下 q 鍵跳出重複執行迴圈
        break
 
# 終止模擬
sim.stopSimulation()</pre>
<p>下載<span> </span><a href="https://nfuedu-my.sharepoint.com/:u:/g/personal/yen_nfu_edu_tw/EVV3NaesdDdNqcoD3xAo96gBqGG4gEJFPknOIt7EfofGlg?e=OfQ4qo">zmqRemoteAPI Python for cad2023.7z</a><span> </span>(需要下載密碼)</p>
<p>在<span> </span><a href="https://github.com/CoppeliaRobotics/scenes/raw/master/otherScenes/simpleMagnetDemo.ttt">simpleMagnetDemo.ttt</a><span> </span>中利用 Lua 以 proximity sensor 感測與物體的距離後, 產生電磁吸引力的範例程式:</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">function sysCall_init()
     -- 初始化 callback 函數，在模擬開始時執行
     sensor = sim.getObject('./sensor')
     -- 取得命名為 'sensor' 的物件 handle。 此處使用 proximity 感測器，用於檢測物體之間的距離
     shape = sim.getObject('.')
     -- 取得目前 script 所依附的物件 handle，即包含此 script 的物件 handle
     sim.setObjectInt32Param(shape, sim.shapeintparam_static, 0)
     -- 將物體設定為非靜態，讓其在模擬中發生動態運動
     nominalForce = 0.001
     -- 設定電磁吸引力的標準值
     enabled = true
     -- 啟用電磁吸引力
     previousPos = sim.getObjectPosition(shape, sim.handle_world)
     -- 取得物體的初始位置並儲存在 previousPos 變數中，用於偵測物體是否移動
end
 
function sysCall_actuation()
     -- 驅動 callback 函數，在每個模擬步驟中執行
     if enabled then
         -- 如果啟用電磁吸引力，執行下列程式碼
         local r, dist, pt, obj = sim.handleProximitySensor(sensor)
         -- 使用 proximity 感測器偵測物體是否接近
         if r &gt; 0 then
             -- 如果偵測到物體
             dist = dist + 0.02
             -- 增加一個 offset，以避免物體接觸時產生無限大的吸引力
             local force = nominalForce / (dist * dist)
             -- 計算吸引力的大小，與距離的平方成反比
             local m = sim.getObjectMatrix(shape, sim.handle_world)
             m[4] = 0
             m[8] = 0
             m[12] = 0
             -- 取得物體的轉換矩陣，不考慮平移部分
             local forceVector = sim.multiplyVector(m, {0, 0, force})
             -- 將力向量從局部座標系轉換為絕對座標系
             sim.addForceAndTorque(shape, forceVector, {0, 0, 0})
             -- 將計算得到的力應用於物體的質心，持續一個 time step
             if notFirstPass then
                 local p = sim.getObjectPosition(shape, sim.handle_world)
                 local dx = {p[1] - previousPos[1], p[2] - previousPos[2], p[3] - previousPos[3]}
                 local d = math.sqrt(dx[1] * dx[1] + dx[2] * dx[2] + dx[3] * dx[3])
                 -- 計算物體是否移動
                 if d &lt; 0.0001 then
                     sim.setObjectInt32Param(shape, sim.shapeintparam_static, 1)
                     sim.resetDynamicObject(shape)
                     enabled = false
                     -- 如果物體沒有移動，將其設為靜態
                 end
                 previousPos = p
             end
         end
     end
     notFirstPass = true
end</pre>
<h2>magnet</h2>
<p><span>利用 Lua 模擬磁力的程式碼:</span></p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">function sysCall_init()
 
-- This line defines the beginning of a function called sysCall_init(). This function is a special callback function in CoppeliaSim that gets called once when the simulation starts.
 
    sensor = sim.getObject('./sensor')
 
-- In this line, the script is getting a reference to an object named "sensor" in the simulation scene. This object is expected to exist within the same hierarchy as the script.
 
    shape = sim.getObject('.')
 
-- Here, the script is getting a reference to the object where the script is attached. The dot . represents the current object.
 
    sim.setObjectInt32Param(shape, sim.shapeintparam_static, 0)
 
-- This line is setting an integer parameter for the "shape" object. Specifically, it's setting the sim.shapeintparam_static parameter to 0. This means that the "shape" object is initially not considered as a static object.
 
    nominalForce = 0.001
 
-- This line sets a variable nominalForce to a value of 0.001. It appears to represent a constant force value used in the script.
 
    enabled = true
 
-- This line initializes a boolean variable enabled to true. This variable seems to control whether the script should apply forces or not.
 
    previousPos = sim.getObjectPosition(shape, sim.handle_world)
 
-- Here, the script is getting the initial position of the "shape" object in the world coordinate system and storing it in the previousPos variable. This will be used later for checking if the object has moved.
 
-- The sysCall_init function sets up initial parameters and conditions for the script. It's executed once at the beginning of the simulation.
 
-- Now, let's move on to the sysCall_actuation function:
 
function sysCall_actuation()
 
-- This line defines the beginning of another special callback function in CoppeliaSim called sysCall_actuation(). This function gets called repeatedly during the simulation to perform actions in each time step.
 
    if enabled then
 
-- This line checks if the enabled variable is true. If it's true, it means the script should apply forces. If it's false, the script won't apply any forces.
 
        local r, dist, pt, obj = sim.handleProximitySensor(sensor)
 
-- Here, the script is using the sim.handleProximitySensor function to check if the proximity sensor (defined earlier as "sensor") is detecting any objects nearby. It returns information about the detected object.
 
        if r &gt; 0 then
 
-- This line checks if r (the return value of the proximity sensor function) is greater than 0. If it is, it means the sensor has detected an object nearby.
 
            dist = dist + 0.02
 
-- This line adds an offset of 0.02 to the dist variable. This offset is added to prevent an infinite force when objects are in direct contact. It's a safety measure.
 
            local force = nominalForce / (dist * dist)
 
-- Here, the script calculates the force to be applied based on the nominalForce and the squared distance (dist) between the object and the detected object. This seems to be a simple inverse square law force calculation.
 
            local m = sim.getObjectMatrix(shape, sim.handle_world)
            m[4] = 0
            m[8] = 0
            m[12] = 0
 
-- These lines retrieve the transformation matrix (m) of the "shape" object with respect to the world coordinate system and set its translational components to 0. This effectively extracts the rotational part of the transformation matrix.
 
            local forceVector = sim.multiplyVector(m, {0, 0, force})
 
-- This line multiplies the modified transformation matrix m by a force vector {0, 0, force} to obtain a force vector in absolute world coordinates.
 
            sim.addForceAndTorque(shape, forceVector, {0, 0, 0})
 
-- Here, the script applies the computed forceVector to the "shape" object using sim.addForceAndTorque. This function applies the force to the center of mass of the object for one simulation time step.
 
            if notFirstPass then
 
-- This line checks if the notFirstPass variable is true. It's used to ensure that this part of the script is executed after the first simulation step.
 
                local p = sim.getObjectPosition(shape, sim.handle_world)
 
-- Here, the script is getting the current position of the "shape" object in the world coordinate system.
 
                local dx = {p[1] - previousPos[1], p[2] - previousPos[2], p[3] - previousPos[3]}
 
-- This line calculates the difference in position (dx) between the current position (p) and the previous position (previousPos) of the object in world coordinates.
 
                local d = math.sqrt(dx[1] * dx[1] + dx[2] * dx[2] + dx[3] * dx[3])
 
-- The script calculates the Euclidean distance d based on the differences in position components dx. This distance is used to check if the object has moved significantly.
 
                if d &lt; 0.0001 then
 
-- This line checks if the object has moved by comparing d to a small threshold value (0.0001). If d is less than the threshold, it means the object hasn't moved significantly.
 
                    sim.setObjectInt32Param(shape, sim.shapeintparam_static, 1)
 
-- If the object hasn't moved significantly, this line sets the sim.shapeintparam_static parameter to 1, making the object static in the simulation.
 
                    sim.resetDynamicObject(shape)
 
-- This line resets the dynamics of the object. It might be necessary to reset the object's dynamics after making it static to avoid any issues.
 
                    enabled = false
 
-- Finally, this line sets the enabled variable to false, which will prevent the script from applying further forces since the object is now considered static and not moving.
 
                end
 
-- The if block is closed.
 
                previousPos = p
 
-- Regardless of whether the object has become static or not, the previousPos variable is updated with the current position for use in the next iteration of the sysCall_actuation function.
 
            end
 
-- The if notFirstPass block is closed.
 
        end
 
-- The if r &gt; 0 block is closed.
 
    end
 
-- The if enabled block is closed.
 
    notFirstPass = true
 
-- This line sets the notFirstPass variable to `true</pre>
<h2>馬達推動</h2>
<p>除了利用磁力吸引, 讓鋼球在軌道運動時能具備足夠動能返回圓形平台外, 另外一種設計是在鋼球 (或其他非鐵材質的圓球) 離開圓形平台孔洞之後, 設法利用隱藏式的馬達帶動機構, 以滾動方式加速圓球, 以便讓圓球返回平台.</p>
<p>有關馬達推動設計, 請參考:<span> </span><a href="https://www.instructables.com/Marblevator-Perpetual/">https://www.instructables.com/Marblevator-Perpetual/</a><span> </span>或<a href="https://youtu.be/xVVpSp6_4iA?si=bpHoiIf-syLPORvT">這個影片</a>.</p>
<p>機電模擬系統:</p>
<p>下載<span> </span><a href="https://nfuedu-my.sharepoint.com/:u:/g/personal/yen_nfu_edu_tw/EfEaYO4E4eBGtTV3QBCP0f0B3JBfrw11LslWmQyqZB75fw?e=Zf7hCp">CoppeliaSimEdu_4.5.1_rev4_for_cd2023.7z</a><span> </span>(需要下載密碼)</p>
<p><a href="https://www.coppeliarobotics.com/helpFiles/">CoppeliaSim 使用者手冊</a>,<span> </span><a href="https://mde.tw/pjcopsim">CoppeliaSim 4.3.0 使用手冊網站</a></p>
<h2>心得</h2>
<p>老師對不起我東西都是嫖來的，但是我已經努力了，至少是東西是自己親手推的，請高抬貴手放過我吧QAQ。</p>
<p><img alt="" height="420" src="/images/I dont know.jpg" width="420"/></p>
<h1 style="width: 100%; height: 100%;">個人評分</h1>
<p>⇓傳送門⇓</p>
<p><a href="https://41136131.github.io/cad2023/content/%E6%9B%B4%E6%96%B0%E6%97%A5%E8%AA%8C.html">更新日誌</a></p>
<p><a href="https://41136131.github.io/cad2023/content/%E6%9B%B4%E6%96%B0%E6%97%A5%E8%AA%8C.html"><img alt="" height="159" src="/images/portal.gif" width="159"/></a></p>
<p><a href="https://41136131.github.io/cad2023/content/%E8%87%AA%E6%88%91%E8%A9%95%E5%88%86.html">自我評分</a></p>
<p><a href="https://41136131.github.io/cad2023/content/%E8%87%AA%E6%88%91%E8%A9%95%E5%88%86.html"><img alt="" height="159" src="/images/portal.gif" width="159"/></a></p>
<h2>更新日誌</h2>
<p>2024/01/11:新增首頁圖片</p>
<p>2024/01/11:新增個人簡介</p>
<p>2024/01/11:新增個人評分</p>
<p>2024/01/16:新增任務一</p>
<p>2024/01/16:新增磁力吸引</p>
<p>2024/01/16:新增magnet</p>
<p>2024/01/16:新增馬達推動</p>
<p>2024/01/16:新增心得</p>
<h2>自我評分</h2>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div2">自評分數:60分</div>
<div>我知道以我的網站想要拿60分確實非常厚臉皮，但是我還是希望這門課可以通過，雖然網頁是在最後一個禮拜趕出來的，而且也沒有什麼東西，不過我還是在個人網頁上花了不少心思跟精力，讓我的網頁從0到有，最重要的是我網頁是我自己用的不假借他人之手，但是不可否認我在遇到瓶頸時受到了其他同學的幫助，但是我還是秉持著自己的作業自己做的精神把它給完成了。</div>
<div></div>
<div></div>
<div><img alt="" height="314" src="/images/430.png" width="550"/></div>
<div></div>
<!-- editor2 結束 -->
<p>
<script src="https://unpkg.com/three@0.144.0/build/three.js" type="text/javascript"></script>
</p>